#+title: Posts
#+author: JD
#+startup: overview
#+hugo_base_dir: ../
#+hugo_front_matter_format: yaml
#+hugo_custom_front_matter: :showToc true
#+hugo_custom_front_matter: :TocOpen false
#+hugo_custom_front_matter: :hidemeta: false
#+hugo_custom_front_matter: :comments: false
#+hugo_custom_front_matter: :canonicalURL: "https://canonical.url/to/page"
#+hugo_custom_front_matter: :disableShare: false
#+hugo_custom_front_matter: :hideSummary: false
#+hugo_custom_front_matter: :searchHidden: true
#+hugo_custom_front_matter: :ShowReadingTime: true
#+hugo_custom_front_matter: :ShowBreadCrumbs: true
#+hugo_custom_front_matter: :ShowPostNavLinks: true

* DONE Creating Transient Menus in Emacs :emacs:tools:transient:@emacs:
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: transient-emacs
:EXPORT_FILE_NAME: index
:EXPORT_DATE: 2024-03-23
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description "Building custom Transient menus is a great way to enhance day to day workflows"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :ShowToc true
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :TocOpen true
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :cover '((image . "transient.png") (alt . "emacs transient menu") (caption . "Image taken from the amazing [Jonas Bernoulli](https://emacsair.me/), developer of Magit & Transient") (relative . true))
:END:

[[https://magit.vc/][Magit]] is an innovative package that provides an amazing interface over git. The complexity of its UI is completely hidden away thanks to another package born out of Magit called [[https://www.gnu.org/software/emacs/manual/html_mono/transient.html][Transient]]. Transient is so innovative that it was added to emacs core in 2021. Understanding at least the basics of Transient can provide alot of value in building tools to enhance various workflows.

[[file:transient-emacs/magit.png]]

[[https://magit.vc/manual/transient/][From the official manual]]

#+begin_quote
Transient is the library used to implement the keyboard-driven â€œmenusâ€ in Magit. It is distributed as a separate package, so that it can be used to implement similar menus in other packages.
#+end_quote

[[https://github.com/positron-solutions/transient-showcase][From Transient Showcase]]
#+begin_quote
Transient means temporary. Transient gets its name from the temporary keymap and the popup UI for displaying that keymap.
#+end_quote

** Understandinding the Basics
A Transient menu is made of up of 3 parts: =prefix=, =suffix= and =infix=.

*Prefix* - represents a command to "open" a transient menu. For example =magit-status= is a prefix which will initialize and open the =magit-status= buffer.

*Suffix* - represents the "output" command. This is whats invoked inside of a transient menu to perform some kind of operation. For example in =magit= calling =magit-switch-branch= is a suffix which has a =(completing-read)= in front of it.

*Infix* - represent the "arguments" or the intermediary state of a transient. For example, adding =-f, --force-with-lease= means you're using an infix for the =magit-push= suffix.

There are 2 additional things to understand about transients:

- Suffixes can call prefixes allowing for "nesting" of "menus." In =magit= when a commit is at point and you call `magit-diff` that is a suffix that is a /really/ just a prefix with it's own set of infixes and suffixes. See Example N below for a more elaborate example of this.
  - Think of it this way: =Prefix -> Suffix -> Prefix -> ...=
- State can be persisted between Suffixes and Prefixes to build very robust UIs that engage in very complex behavior while exposing a simple view to the user.

** Personal Transients
While the actual model is much more complex than I've lead on and has many more domain concepts to understand than I'm going to layout, defining simple transients can enhance your workflow in meaningful ways once you at least understand the basics. This is by no means a comprehensive guide on Transients but merely a (hopefully) educational and useful overview. For an incredible guide, checkout [[https://github.com/positron-solutions/transient-showcase][positron-solutions Transient Showcase]] which is one of the most thorough guides I've ever seen. If any information I share here is different in Positrons guide, trust Positron.

/*Note:* Each of the Examples work and can be evaluated inside of Emacs and I encourage you to do so!/

#+begin_details
#+begin_summary
ðŸ’¬ Evaluating the Examples Quick Guide
#+end_summary
	Here's how to evaluate the example code in Emacs in case you don't know or forgot. I encourage you to type each example out instead of copying and pasting.

	1. Create an `example.el` file anywhere -- alternatively a config file can be used for this if preferred.
	2. Type out the example you're reading over (or copy and paste).
	3. Now you can do one of two things
	- Call `M-x (eval-buffer)` to evaluate the whole buffer (recommended since these examples will build on each other)

	- Create a region around the current example code and call `M-x (eval-region)`
	4. Run the prefix command we're working on with `M-x (my/transient)`
#+end_details


* Managing Local Services in Emacs with Prodigy :emacs:packages:tools:@emacs:
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: emacs-prodigy
:EXPORT_FILE_NAME: index
:EXPORT_DATE: 2024-03-15
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description "Prodigy is an Emacs package that allows you to manage local services easily."
:END:

[[https://github.com/rejeep/prodigy.el][Prodigy]] is an incredible tool of convenience for me. I've been slowly migrating my entire workflow into Emacs and Prodigy has become a staple in my day to day.

** What is Prodigy?
#+begin_quote
Manage external services from within Emacs

I came up with the idea when I got to work one Monday morning and before I could start working I had to manually start ten or so services.

To get rid of this tedious work, I started working on this Emacs plugin, which provides a nice and simple GUI to manage services.

 -- Johan Andersson (author of Prodigy)
#+end_quote

This has to be probably the most "Emacs user" solution to a problem I've ever heard.

In short, you can define a list of services in your configuration, and in turn, are given a simple UI to manage those services. This site is currently built with [zola](https://www.getzola.org/) and the command to start the server is `zola serve`. Instead of managing a terminal buffer or _worse_ switching to a terminal app I can define the following in my config:


* DONE Tips for Breaking into the Tech Industry :advice:@career:
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: breaking-into-tech
:EXPORT_FILE_NAME: index
:EXPORT_DATE: 2017-12-28
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :description "It took me a long time to find a job, so I thought I'd share my most useful advice on the matter. It's an uphill battle, but once you get the first one, the rest are easy."
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :cover '((image . "./image.url") (alt . "alt text") (caption . "caption") (relative . false) (hidden . true))
:END:

#+begin_quote
This is a repost of my original 2017 blog post. It maybe a little outdated.
#+end_quote

I recently got my first developer job as a Quality Assurance Engineer at a company called [Modern Message](http://modernmsg.com) and I want to share a few tips on things I did to help me eventually land this job.

I'm a student at [Bloc](http://bloc.io) which is a remote, self-paced developer bootcamp. I managed to pick their longest track called the Software Engineering Track.

** It's a Numbers Game
When I was searching for a job, I assumed 5% of my applications would result in a job. That's a conservative number I think, I don't even remember where I got that from, but it gave me a goal. So let's assume, that stat is correct.

If 5% of your applications result in a job, lets say 20% actually call you after applying. This is great news. That's 20 out of 100 applications. That's 20 opportunities. If your working hard, just 1 of those opportunities is enough.

While I'm sure that the actual stats are much different based on a very large number of factors, that stat still _is_ some number though, which means each application you send out, gets you one step closer to the employer that'll make you an offer. Keep this at the forfront of your mind, cause finding your first gig can be real up hill struggle. Just remember, each place you apply, increases your chances of getting an offer. It may seem basic, but it kept me going after sending out my 120th application.

** The Industry
There's a few things that I felt like companies were really looking for when it came to finding candidates to work for them:

- Industry Fit
- Culture Fit
- Technical Fit

*** Industry Fit

A business wants to know you're passionate about what you're doing. That you're keeping up with issues/news about the software industry. There's plenty of places to get this info like [HackerNews](https://news.ycombinator.com) or [Reddit](https://reddit.com/r/programming). You can easily see trends and see the focus of people in the industry to gauge better what you should be learning about and what you can talk about in interviews.

ES6 was a new thing when I was hunting, so being able to at least discuss it, even at just a high level, benefitted me in a couple interviews.

*** Culture Fit

This is huge. Most software companies understand that programming isn't a science where you hold all the knowledge in your heard about everything. Very few fields are that way. What's important is that you show that you're always willing to learn and accept feedback. This is especially true for junior level developers. Showing that you take initiative to grow in your field, and you can take criticism well will help take you a long way with potential employers.

*** Technical Fit

This is the most obvious, but should definitely still be stated. Learn to code. You don't have to know everything, but understand the fundamentals really well. If you're studying Ruby like I did, make it a point to study up on topics like OOP, inheritence, and even going deep-ish on a framework. All these things will just make you a better programmer, but they'll also give you things to speak to in interviews.

It's important that you just build things also. This gives you practice in integrating technologies, thinking about planning, architecture and system design. Just build something from scratch. If you're not sure what to build, build a clone of a popular website. I think building a Pinterest clone was the first project I ever did. This will also give you stories to talk about in interviews.

** Getting Started

I started my job search about a month into Bloc. I didn't know much and had only built very small applications by following tutorials and stuff, but my mentor encouraged me to just start applying. I initiated my first iteration of a blog, got my LinkedIn all nice and up to date and started the long process.

The easiest thing to do when starting is to just sit down and clean up your LinkedIn.
- I made sure everything was up to date.
- I made sure my skills reflected what I was studying (Rails, Javascript, Ruby, SQLite etc...).
- I updated my profile picture to something that I looked relatively professional in but not "suit and tie" professional."

Mostly just basic stuff.

I then focused a lot of time and effort on my resume. I had it reviewed by peers, mentors, and anyone I spoke to that had seen it basically. I used [[http://creddle.io][Creddle]] for my first iteration before moving to something custom. Here's a few things to make sure of:
- Only ONE page for my resume.
- I made sure I explained actual accomplishments under my previous employment descriptions.
- I put my skill list at the very top. (A lot of recruiters for companies aren't that technical, so they are using template matching. I made sure the first thing htey saw on my resume were the words that would match the template they got from the engineering department).
- I put references on there as well as links to my Github and website.
- I listed "potential weak points" at the bottom of the resume, decreasing the chances it would get focused on.

A resume MUST be clear and concise, only focusing on whats important, not useless details about the Chess Club you were in in highschool.

This is the big point.

** Network

Network, Network, Network. I can't say it enough. I'm not the most out going person in the world, I can even be socially awkward in odd situations. But I had to really work at that. Mostly by just practicing what I would say, or listing out the questions I would ask before the interaction. A whole blog could be devoted to this I think.

*Go to Meet Ups*

At Meet Ups you can engage with people you already have a common interest in, making initiating conversation a tad bit easier. I recommend coming up with 3-4 questions you'll ask upon meeting people, like:

- Where do you work?
- How long have you been programming with x technology?
- How'd you learn?
- What challenges are you encountering at work?

I did this to almost every person I met at Meet Ups.

*Coffee*

I asked about 8 developers for coffee in my job search. Through that I was able to get to know them, pick their brains and learn. Another engineer, Haseeb Qureshi has a great [blog](http://haseebq.com/how-to-break-into-tech-job-hunting-and-interviews/) on this whole topic, especially networking. If you're still reading this and not his blog (which is totally the wrong move by the way) here's what I did.

I went to a Meet Up and asked one of the obvious experienced engineers out for coffee. He was very kind and obliged. I paid, and got to sit down with him for almost 2 hours just picking his brain. At the end I asked, "I'm really trying to get a job as a developer using x technology, mostly right now I'm just trying to get to know people and learn from them. Do you have someone else you can reccommend I talk to?"

I've heard of these leading to job offers and such, but I ended up just meeting 8 good solid, very nice engineers. It turns out engineers are just people who like to talk about what they do, like most people do. This not only brought a level of comfort meeting new people, but also helped me to learn about the industry in my area.

** Practice

There's a couple of things to practice when looking for developer job.
- Whiteboarding
- Answering Questions

*** Whiteboarding

This is some what of a controversial subject. It's good to go into it with the mentaility of solving problems instead of actually coding. I did several whiteboarding interviews that involved dealing with collisions in hashes, implementing a method on a string like `.reverse`, and taking an algorithm and making it faster. All these are skills that can be practiced easily, but there's a method which will give you great results.

1. Find the problem
   a. CodeWars
   b. Cracking the Coding Interview
   c. Exercism.io
2. Speak out loud as you try to solve the problem.
   a. Ask yourself questions about the data. ALWAYS.
   b. Ask yourself about output.
   c. Explain your thought process and theory before writing one line of code.
3. Code and explain the solution

Using these steps will give you good practice for what whiteboarding is like. Most of the hiring managers I've spoken too, don't emphasize the right answer as much as being able to solve the problem and communicate the _idea_ behind the solution.

*** Answering Questions

It's definitely in your best interest to practice answering questions about your coding skills. One of the questions I frequently rehearsed was "what's a big challenge that you've experienced and how did you tackle that?" I came up with both a "soft-skills" answer and a "technical-skills" answer to that question. I rehearsed the answer over and over so I didn't have to think about it much. I made it clear and concise, with enough detail to make sense, but not enough that I bored the interviewer to death. I'm sure a Google search can turn up hundreds of answers for questions that'll be asked in an interview. Google it and come up with your answers before hand.

** Cue the Offer

I was hell bent on meeting every Ruby engineer in the DFW area. I would frequently skip the local "hacknights" as I was intimidated by potentially letting a senior engineer peak at my super lame code. Thankfully, one night when I was supposed to stay home, I randomly decided to go to the hacknight. I went and met the CTO of the company I'd later get an offer from.

I think just personality wise we got a long really well and hit it off. I'm sure that building this level of rapport was a BIG part of how I landed the job. After talking about random things like (Minecraft), I asked his (and the other devs there that would later become collegues) advice on finding a Jr Developer rails job in Dallas. This lead to a great conversation about the open positions at Modern Message and I got an offer 2 1/2 weeks later.

I ultimately think that it was because I "practicing" building rapport with those other engineers that I was able to build rapport with Daniel and the other developers which ended up increasing my chances of getting the job.

** It's a Grind

It's definitely a grind. My thoughts go back to my days of playing World of Warcraft... Anyway. I have a pending post I'm working on about my actual job search and how I organized it using a Trello board. This post is already too long.

Good luck on your job search and remember, *network*.
